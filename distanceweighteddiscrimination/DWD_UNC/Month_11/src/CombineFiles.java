/************************************************************* 
 *	DWD (Distance Weighted Discrimination)
 *	
 *	This software is developed by LCCC and Statistics at UNC
 *	It is supported by caBIG from NCI and is Open source 
 *
 *************************************************************/
 
package edu.unc.LCCC.caBIG.DWD.javaCode.processfile;

import java.io.*;
import java.util.*;
import javax.swing.*;

/************************************************************* 
 *	CombineFiles.java
 *
 *	Read two text files
 *	Find the comman keys and merge two files based on the common keys
 *	Put the keys back to the output file generated by BatchAdjustSM.exe
 *
 *	Version: v1.0
 *	Author: Everett Zhou
 *	Date: 11/22/2004
 *
 *************************************************************/

public class CombineFiles {
	
	 private static StringTokenizer st;	 

	 // the number of numeric columns
	 private static int numValues1 =0;
	 private static int numValues2 =0;
	 	 
	 // To store the first line of two text files
	 private static Vector title1Vec;
	 private static Vector title2Vec;
	 private static HashMap hmAnotation1 = new HashMap();
	 private static HashMap hmValue1 = new HashMap();
	 private static HashMap hmValue2= new HashMap();

	 private static String commonKeys[];

	   /* Test missing value in a string
	    * If the two "\t" are continuous, then a value is missing
	    * @param textFile: the name of a file
	    * @param s: the current string
	    * @param row: the row of the text file
	    * @return:boolean
	    */
     public static boolean testMissingValue (String textFile,String s, int row){
     	int len = s.length();
     	boolean missing = false;
     	for (int i =0; i<len-2; i++) {
     		String s1 = s.substring (i, i+1); 
     		String s2 = s.substring (i+1, i+2); 

     		if (s1.equalsIgnoreCase("\t")&& s2.equalsIgnoreCase("\t")) {
     			missing = true; 
               	JFrame jf = new PopUpError ("<html><p>There is a <FONT COLOR=RED SIZE =4>MISSING VALUE</FONT> in the No. " 
               			+ row +" row of "+textFile +" file</html>","Fix the File(s) and Terminate the Program");
         		jf.show(); 
         	   	break;		
     		}
     	}
     	return missing;
     } /*End of testMissingValue */
 
 
	   /* Test non-digital value in a string
	    * If a char is not "-" or "." and can not be converted to a didgit
	    *  then there is a non-digital value
	    * @param textFile: the name of a file
	    * @param s: the current string
	    * @param row: the row of the text file
	    * @return:boolean
	    */
     public static boolean testDigital (String textFile,String s, int row){
     	int len = s.length();
     	boolean nonDigit = false;
     	
     	for (int i =0; i<len; i++) {
     		char c =s.charAt(i);
     		if (Character.isDigit (c)||(Character.toString(c).equalsIgnoreCase("-"))
     			||(Character.toString(c).equalsIgnoreCase("."))) {
     			
     		} 
     		else {
     			nonDigit = true; 
               	JFrame jf = new PopUpError ("<html><p>There is a <FONT COLOR=RED SIZE =4>NON DIGIT VALUE</FONT> in the No. " 
               			+ row +" row of "+textFile +" file</html>", "Fix the File(s) and Terminate the Program");
         		jf.show(); 
         		break;       			
     		}    	
     	}
     	return nonDigit;  
     } /*End of testDigital */

     
	   /* To read the text file for the first line and put them into a vector
	    * The first column (gene list) is used as the key
	    * The second column (gene name is skipped)
	    * The rest of columns are the value for each sample 
	    * @param textFile: the name of a file
	    * @param rowStart: the data row starts
	    * @param colStart: the data column starts
	    * @param IDCol: the identification column
	    * @return: a vector
	    */	      
     public static Vector createTitleVector (String textFile, int rowStart, int colStart, int IDCol, int fileIndicator) {
     	
     	/* A vector holds the values */ 
     	Vector v = new Vector();     	 
         try {
         	
     		 String s, myKey, myValue, temp;
     		 
             FileReader fr = new FileReader (textFile);
             BufferedReader br = new BufferedReader (fr);
             
             int rowCount =1;
             while (rowCount<rowStart) {
              
             	if ((s=br.readLine()) != null) {
             		/* Test any missing values */
					if (testMissingValue (textFile, s, rowCount)){
						return null;
					}
              	
              		st = new StringTokenizer (s,"\t");
              	
              		/*First token is the key */
              		if (IDCol==1) {
              			if(st.hasMoreTokens()){
              				myKey = st.nextToken().trim();
              				v.add (myKey);
              			} 
              		} else { /*Skip a few columns */
              			int IDCount =1;
              			while (IDCount <IDCol){
              				if(st.hasMoreTokens()){
              					temp = st.nextToken().trim();
              				}      				
              				IDCount++;
              			}
              			if(st.hasMoreTokens()){
              				myKey = st.nextToken().trim();
              				v.add (myKey);
              			}              			
              		}
              		// Second or more columns token is the gene name -- not needed for the second file
              		if (fileIndicator == 2){	
              			int geneNameCount =colStart-IDCol-1;
              			while (geneNameCount>0){
              				if(st.hasMoreTokens()){
              					temp = st.nextToken().trim();
              				} 
              				geneNameCount--;              	
              			}
              		}
              		/*rest of tokens from a line is sample value  */               
              		while (st.hasMoreTokens()) {
                    	myValue = st.nextToken().trim();
                    	v.add (myValue);                    
                   	}                                       
             	}
             	rowCount++;             
             }    
             fr.close();
          }
         
         catch (IOException ioe) {
             System.out.println ( "File not found or wrong file");
             System.out.println ( "IOException message = "+ ioe.getMessage() );
         }
         return v;     	    	
     } /* End of createTitleVector*/

     
	   /* To read the text file to create two hashmaps
	    * The first column (gene list) is used as the key
	    * The second column (gene name is skipped)
	    * The rest of columns are the value for each key, 
	    * but it is not a single value, it is an arraylist
	    * @param textFile: the name of a file
	    * @param rowStart: the data row starts
	    * @param colStart: the data column starts
	    * @param IDCol: the identification column
	    * @param fileIndicator: if =1, the first file, else =2, the second file
	    * 
	    */	           
     public static void createHashMap (String textFile, int rowStart, int colStart, int IDCol, int fileIndicator) {
     	
        try {
         	 String s, myValue, temp;     		 
     		 /*To gurantee the key is not null */
     		 String myKey ="Gene1";

             FileReader fr = new FileReader (textFile);
             BufferedReader br = new BufferedReader (fr);

             /* rowCount serves two purposes
              * Skip a few row and 
              * track which row has missing and non-digital values
              */
             int rowCount =1; 
             while (rowCount<rowStart) {                          
             	if ((s=br.readLine()) != null) {
             	}
             	rowCount++;
             }
                        
             
             /* For the first file anotation will be added, so another hashmap is needed*/
             if (fileIndicator==1) {
             	while ((s=br.readLine()) != null) {
             		/* Test any missing values */
             		if (testMissingValue (textFile, s, rowCount)){
             			return;
             		}							              	
             		st = new StringTokenizer (s,"\t");

             		/*First token is the key */
             		if (IDCol==1) {
             			if(st.hasMoreTokens()){
             				myKey = st.nextToken().trim();
             			} 
             		} else { /*Skip a few columns */
             			int IDCount =1;
             			while (IDCount <IDCol){
             				if(st.hasMoreTokens()){
             					temp = st.nextToken().trim();
             				}      				
             				IDCount++;
             			}
             			if(st.hasMoreTokens()){
             				myKey = st.nextToken().trim();
             			} 
              		
             		}
              	
             		/* Second or more columns token is the gene name -- only needed for the first file*/
             		ArrayList myListAnnotation = new ArrayList();
             		int geneNameCount =colStart-IDCol-1;
             		while (geneNameCount>0){
             			if(st.hasMoreTokens()){
             				temp = st.nextToken().trim();
             				myListAnnotation.add (temp);
             			} 
             			geneNameCount--;              	
             		}
             		hmAnotation1.put (myKey,myListAnnotation);  
             		
             		/*rest of tokens from a line is sample value */ 
             		ArrayList myListValue = new ArrayList();
             		while (st.hasMoreTokens()) {
             			myValue = st.nextToken().trim();
             			/* Test value is digit */
             			if (testDigital (textFile, myValue, rowCount)){
             				return;
             			}                                        
             			myListValue.add (myValue);                    
             		} 
             		rowCount++; 
             		hmValue1.put(myKey, myListValue); 
             		//writer.flush();
             	}                 
             } 
             else if (fileIndicator==2) {
             	while ((s=br.readLine()) != null) {
             		/* Test any missing values */
             		if (testMissingValue (textFile, s, rowCount)){
             			return;
             		}							              	
             		st = new StringTokenizer (s,"\t");

             		/*First token is the key */
             		if (IDCol==1) {
             			if(st.hasMoreTokens()){
             				myKey = st.nextToken().trim();
             			} 
             		} else { /*Skip a few columns */
             			int IDCount =1;
             			while (IDCount <IDCol){
             				if(st.hasMoreTokens()){
             					temp = st.nextToken().trim();
             				}      				
             				IDCount++;
             			}
             			if(st.hasMoreTokens()){
             				myKey = st.nextToken().trim();
             			} 
              		
             		}
              	
             		/* Second or more columns token is the gene name -- not needed */
             		int geneNameCount =colStart-IDCol-1;
             		while (geneNameCount>0){
             			if(st.hasMoreTokens()){
             				temp = st.nextToken().trim();
             			} 
             			geneNameCount--;              	
             		}
              	               
             		/*rest of tokens from a line is sample value */ 
             		ArrayList myListValue = new ArrayList();
             		while (st.hasMoreTokens()) {
             			myValue = st.nextToken().trim();
                    
             			/* Test value is digit */
             			if (testDigital (textFile, myValue, rowCount)){
             				return;
             			}                                        
             			myListValue.add (myValue);                    
             		}                    
             		rowCount++; 
             		hmValue2.put(myKey, myListValue); 
             		//writer.flush();
             	}                 
             } 
             fr.close();
         }
         catch (IOException ioe) {
             System.out.println ( "File not found or wrong file");
             System.out.println ( "IOException message = "+ ioe.getMessage() );
         }
         //return myMap;     	   	
     } /* End of createHashMap*/
 
     
     /* Print out an arraylist
      * @param al: arraylist to be printed out
      */
     public static void printArraylist (ArrayList al){
		int listLen = al.size();
		String element;
		int count =0;
		while (count <listLen) {
			element = (String) al.get(count);
			System.out.print(element +"\t");
			count ++;
		} 
		System.out.println();
     }

     
	   /* To find the common keys in two arrays
	    * @param arr1[]: first array
	    * @param arr12[]: second array
	    * @return: an array
	    */
    public static String [] findCommonKeys (Object arr1[], Object arr2[]) {
    	int len1 = arr1.length;
    	int len2 = arr2.length;
    	
    	int count=0;
    	String s1, s2;
    	
        String commonKeys[] = new String[len1+len2];
        
        /* initialize the array to "" */
        for (int k=0; k<len1+len2; k++){
        	commonKeys[k]="";
        }
        
        for (int i=0; i<len1; i++){
        	s1= (String) arr1[i];        	 
        	for (int j=0; j<len2; j++) {
        	    s2= (String) arr2[j];
        	    if (s1.equalsIgnoreCase (s2)){
        	    	commonKeys[count] = s1;
        	    	count++;
        	    }	        		
        	}
        }    	
    	String newCommonKeys [] = new String [count];
    	
    	for (int m=0; m<count; m++) {
    		newCommonKeys [m] = commonKeys [m];
    	}
    	return newCommonKeys; 
    	
    } /* End of findCommonKeys */

    
	   /* Pre-process two text files and combine them into one file for BatchAdjustSM.exe
	    * @param source1: source of the first file
	    * @param textFile1: the name of the first file
	    * @param rowStart1: the data row in the first file starts
	    * @param colStart1: the data column in the first files tarts
	    * @param IDCol1: the identification column in the first file
	    * @param source2: source of the second file
	    * @param textFile2: the name of the second file
	    * @param rowStart2: the data row in the second file starts
	    * @param colStart2: the data column in the second files tarts
	    * @param IDCol2: the identification column in the second file	   
	    */	           
	public static void filePreProcess (String source1,String textFile1, int rowStart1, int colStart1, int IDCol1,
				String source2,String textFile2,int rowStart2, int colStart2, int IDCol2) throws IOException {

		/* Read in the first text file to create a title vector and hashmap */

		/* Title vector */
		title1Vec = new Vector();		
		title1Vec= createTitleVector (textFile1,rowStart1,colStart1,IDCol1,1);
		
		/* To find number of columns for values */
        numValues1 =(title1Vec.size()/(rowStart1-1)) -(colStart1-IDCol1);
 
	
		/* create the hashmaps for both data and annotation */
        createHashMap (textFile1,rowStart1,colStart1,IDCol1,1);
						
		/*Get all keys and put into a set */
		Set keySet1 = hmValue1.keySet();
		
		/* Convert the key set into array to get a common key arrays */	
		Object key1Array[] =  keySet1.toArray();


 		/*Read in the second text file to create a title vector and data hashmap only */
		
		/* Title vector */
		title2Vec = new Vector();		
		title2Vec= createTitleVector (textFile2,rowStart2,colStart2,IDCol2,2);
			
		/* To find number of columns for values */
        numValues2 =(title2Vec.size()/(rowStart2-1))-1;

        createHashMap (textFile2,rowStart2,colStart2,IDCol2,2);
		
		/*Get all keys and put into a set*/
		Set keySet2 = hmValue2.keySet();
		
		/* Convert the key set into array to get a common key arrays */	
		Object key2Array[] =  keySet2.toArray();
	
		/*To get the common keys */
		commonKeys = findCommonKeys (key1Array, key2Array);
		
        int len = commonKeys.length;

        
        /* To combine the data and write to a text file*/

 	   String fileName = "C:\\DWD\\DWDdata\\DWD_Input.txt";
 	   PrintWriter writer = new PrintWriter(new FileWriter (fileName, false));

		/* Print out the title: numValues1 for 1s and numValues2 for 2s */
		for (int i=0; i<numValues1;i++) {
			writer.print ("1" +"\t");
		}

		for (int j=0; j<numValues2-1;j++) {
			writer.print ("2" +"\t");
		}
		writer.println("2");		
		
		/* use common keys to retrieve everything */
		String keys ="";
		ArrayList aList1= new ArrayList();
		ArrayList aList2= new ArrayList();
		
		for (int k=0; k<len;k++) {
			keys = commonKeys[k];
			
			/* retrive stuff from the first file*/
			aList1=(ArrayList) hmValue1.get(keys);

			Iterator it1= aList1.iterator();
			while (it1.hasNext()) {
				//System.out.println ("Here" + it1.hasNext());
				writer.print(it1.next() +"\t");
			}			
			
			/*retrive stuff from the second file
			 * One extra tab caused problem in BatchAdjustSM.exe
			 */
			aList2=(ArrayList) hmValue2.get(keys);
			int listLen = aList2.size();
			String element;
			int count =0;
			while (count <listLen-1) {
				element = (String) aList2.get(count);
				writer.print(element +"\t");
				//writer.flush();
				count ++;
			}
			/*last element */
			element = (String) aList2.get(count);
			writer.println(element);
			writer.flush();
		}		
        writer.close();
 	   	   		
	} /* End of filePreProcess*/
		

	   /* Post-process the text file output from BatchAdjustSM.exe and
	    * combine this file with  title vectors and keys
	    * It is used for Non-Standardized DWD
	    * 
	    * @param SaveFileIndicator:indicate whether there is a row for the source 
	    * @param source1: source of the first file
	    * @param source2: source of the second file
	    * @param colStart1: the data row in the first file starts
	    * @param IDCol1: the data column in the first file starts
	    * @param fileNameIn: the name of the file from BatchAdjustSM.exe
	    * @param fileNameOut: the name of the file with keys	   
	    */	   	
	public static void filePostProcess (String SaveFileIndicator, String sourse1, int colStart1, int IDCol1, String sourse2, String fileNameIn,String fileNameOut)
		 throws IOException {
		 	
 	    PrintWriter writer = new PrintWriter(new FileWriter (fileNameOut, false));		 	
		
 	    /* For the title first */
		/* Store key name */
		writer.print("GeneID" +"\t");
		
		/* Store the rest of sample name */
		String temp;
	
		Iterator it1 = title1Vec.iterator();
		/* Skip the first element */
		if (it1.hasNext()) {
			temp =(String) it1.next();		
		}
				
		while (it1.hasNext()) {
			writer.print(it1.next() + "\t");			
		} 		

		Iterator it2 = title2Vec.iterator();		
		/* Skip the first element which has been replaced by GeneID */
		if (it2.hasNext()) {
			temp = (String) it2.next();		
		}
		
		while (it2.hasNext()) {
			writer.print(it2.next() + "\t");			
		}
		writer.println();
//-----------------------------------------------
		/* For the content now */
		try {         	
     		 String s, myValue;
     		 int count=0; /* To iterate the common key array*/
 
             FileReader fr = new FileReader (fileNameIn);
             BufferedReader br = new BufferedReader (fr);
             
             /*Need to write the file indicator to the outputfile*/
             if (SaveFileIndicator.equalsIgnoreCase("YES")) {
                writer.print("Sourse" +"\t");
         		
                 /* Add tabs for the annotation*/
                 int geneNameCount =colStart1-IDCol1-1;     		
                 while (geneNameCount>0){
         			writer.print("Null"+"\t");
          			geneNameCount--;              	     		
                 }
         		
                 if ((s=br.readLine()) != null) {
                 	st = new StringTokenizer (s,"\t");
                 	while (st.hasMoreTokens()) {
                        myValue = st.nextToken().trim();
                        /* After BatchAdjustSM.exe, the first line is -1 and 1*/
                        if (myValue.equals ("-1")){
                        	myValue = sourse1;                    	
                        }
                        else {
                        	myValue = sourse2;
                        }
                        writer.print(myValue +"\t");
                    } 
                 	
                 	writer.println();
                 }            	
             } else {
             	if ((s=br.readLine()) != null) {
             		/*Skip the first line*/
             	}             	
             }
             
             while ((s=br.readLine()) != null) {

              	st = new StringTokenizer (s,"\t");
                String keys = commonKeys[count];
                
                writer.print (keys + "\t");
                
                /* Add the annotation elements*/
                ArrayList aList=(ArrayList) hmAnotation1.get(keys);    			
    			Iterator itTemp= aList.iterator();    			
    			while (itTemp.hasNext()) {
    				//System.out.println ("Here" + itTemp.hasNext());
    				writer.print(itTemp.next() +"\t");
    			}			                
                
    			/* Then the data elements*/
              	while (st.hasMoreTokens()) {
                    myValue = st.nextToken().trim();
                    writer.print(myValue +"\t");                    
                } 
                count++;   
                writer.println(); 
                writer.flush();
             }                              
             fr.close();
          }
         
         catch (IOException ioe) {
             System.out.println ( "File not found or wrong file");
             System.out.println ( "IOException message = "+ ioe.getMessage() );
         }
        writer.close();		 	
	} /* End of filePostProcess*/


	   /* Post-process the text file output from BatchAdjustSM.exe and
	    * combine this file with  BioAssays and designElement keys
	    * It is used for Non-Standardized DWD MAGE-ML
	    * 
	    * @param SaveFileIndicator:indicate whether there is a row for the source 
	    * @param source1: source of the first file
	    * @param source2: source of the second file
	    * @param colStart1: the data row in the first file starts
	    * @param IDCol1: the data column in the first file starts
	    * @param fileNameIn: the name of the file from BatchAdjustSM.exe
	    * @param fileNameOut: the name of the file with keys	   
	    */	   	
	public static void filePostProcess (String SaveFileIndicator, String sourse1, String bioAssayNameList1 [], String sourse2, String bioAssayNameList2 [], List commonDesignElement,String fileNameIn,String fileNameOut)
		 throws IOException {
		 	
	    PrintWriter writer = new PrintWriter(new FileWriter (fileNameOut, false));		 	
		
	    /* For the title first */
		/* Store key name */
		writer.print("GeneID" +"\t");
		
		/* Store the rest of sample name */
		for (int i=0; i<bioAssayNameList1.length; i++){
			writer.print(bioAssayNameList1[i] +"\t");
		}

		for (int i=0; i<bioAssayNameList2.length; i++){
			writer.print(bioAssayNameList2[i] +"\t");
		}
		writer.println();
//-----------------------------------------------
		/* For the content now */
		try {         	
  		 String s, myValue;
  		 int count=0; /* To iterate the common key array*/

          FileReader fr = new FileReader (fileNameIn);
          BufferedReader br = new BufferedReader (fr);
          
          /*Need to write the file indicator to the outputfile*/
          if (SaveFileIndicator.equalsIgnoreCase("YES")) {
             writer.print("Sourse" +"\t");
     		
              if ((s=br.readLine()) != null) {
              	st = new StringTokenizer (s,"\t");
              	while (st.hasMoreTokens()) {
                     myValue = st.nextToken().trim();
                     /* After BatchAdjustSM.exe, the first line is -1 and 1*/
                     if (myValue.equals ("-1")){
                     	myValue = sourse1;                    	
                     }
                     else {
                     	myValue = sourse2;
                     }
                     writer.print(myValue +"\t");
                 } 
              	
              	writer.println();
              }            	
          } else {
          	if ((s=br.readLine()) != null) {
          		/*Skip the first line*/
          	}             	
          }
          
          while ((s=br.readLine()) != null) {

           	//st = new StringTokenizer (s,"\t");
             String keys = (String)commonDesignElement.get(count);
             
             writer.print (keys + "\t");
             
 			/* Then the data elements*/
             writer.print (s);
           	/*while (st.hasMoreTokens()) {
                 myValue = st.nextToken().trim();
                 writer.print(myValue +"\t");                    
             } */
             count++;   
             writer.println(); 
             writer.flush();
          }                              
          fr.close();
       }
      
      catch (IOException ioe) {
          System.out.println ( "File not found or wrong file");
          System.out.println ( "IOException message = "+ ioe.getMessage() );
      }
     writer.close();		 	
	} /* End of filePostProcess*/

	
	   /* Post-process the text file output from BatchAdjustSM.exe and
	    * combine this file with  title vectors and keys
	    * It is used for Standardized DWD
	    * Overload the previos function with two arraay as inputs
	    * 
	    * @param SaveFileIndicator:indicate whether there is a row for the source  
	    * @param source1: source of the first file
	    * @param colStart1: the data row in the first file starts
	    * @param IDCol1: the data column in the first file starts
	    * @param source2: source of the second file
	    * @param arr[][]: a standardized DWD output array from BatchAdjustSM.exe
	    * @param ones[]: count -1 and 1 in the DWD output files
	    * @param fileNameOut: the name of the file with keys	   
	    */	  
	
	public static void filePostProcess (String SaveFileIndicator, String sourse1, int colStart1,int IDCol1,String sourse2, double arr[][], int ones[] ,String fileNameOut)
		 throws IOException {
		 	
 	    PrintWriter writer = new PrintWriter(new FileWriter (fileNameOut, false));		 	
		
		/* Store key name */
		writer.print("GeneID" +"\t");
		
		/* Store the rest of sample name */
		String temp;
		
		Iterator it1 = title1Vec.iterator();
		/* Skip the first element */
		if (it1.hasNext()) {
			temp =(String) it1.next();		
		}				
		while (it1.hasNext()) {
			writer.print(it1.next() + "\t");			
		} 
		
		Iterator it2 = title2Vec.iterator();		
		/* Skip the first element which has been replaced by GeneID */
		if (it2.hasNext()) {
			temp = (String) it2.next();		
		}
		
		while (it2.hasNext()) {
			writer.print(it2.next() + "\t");			
		} 
		writer.println();
//-----------------------------------------------         	
     	int count=0; /* To iterate the common key array*/
     	/*Need to write the file indicator to the outputfile*/
     	 if (SaveFileIndicator.equalsIgnoreCase("YES")) {
         	/* Write out the source */
            writer.print("Sourse" +"\t");
            
            /* Add tabs for the annotation*/
            int geneNameCount =colStart1-IDCol1-1;     		
            while (geneNameCount>0){
    			writer.print("Null"+"\t");
    			geneNameCount--;              	     		
            }
            /* ones [] has two numbers, first for the number of 1, second for 2 */        
            int nOnes = ones[0];
            int nTwos = ones[1];
            
            /* For the second source */
            while (nOnes >0 ) {
               	writer.print(sourse1 +"\t");
               	nOnes--;
             }

            /* For the first source */
            while (nTwos >0 ) {
               	writer.print(sourse2 +"\t");
               	nTwos--;
            }
            writer.println();     	 	
     	 }
     		
        /* Write out the DWD standardized output array*/
        int row = arr.length;
    	int col = arr[0].length;
     		
    	for (int i=0; i<row;i++){
    		//writer.print (commonKeys[count] + "\t");
            String keys = commonKeys[count];
            writer.print (keys + "\t");
            
            /* Add annotation back first*/
            ArrayList aList=(ArrayList) hmAnotation1.get(keys);
			Iterator itTemp= aList.iterator(); 			
			while (itTemp.hasNext()) {
				writer.print(itTemp.next() +"\t");
			}			
    		
			/* The add data elements back*/
    		for (int j=0; j<col; j++) {
                writer.print(arr[i][j] +"\t"); 
    		}
            count++;   
            writer.println(); 
            writer.flush();
     	}
        writer.close();
       	
	}	/* End of filePostProcess*/

	   /* Post-process the text file output from BatchAdjustSM.exe and
	    * combine this file with  BioAssays and DesignElements
	    * It is used for Standardized DWD for MAGE-ML
	    * Overload the previos function with two arraay as inputs
	    * 
	    * @param SaveFileIndicator:indicate whether there is a row for the source  
	    * @param source1: source of the first file
	    * @param colStart1: the data row in the first file starts
	    * @param IDCol1: the data column in the first file starts
	    * @param source2: source of the second file
	    * @param arr[][]: a standardized DWD output array from BatchAdjustSM.exe
	    * @param ones[]: count -1 and 1 in the DWD output files
	    * @param fileNameOut: the name of the file with keys	   
	    */	  
	
	public static void filePostProcess (String SaveFileIndicator, String sourse1, String bioAssayNameList1 [], 
			String sourse2, String bioAssayNameList2 [], List commonDesignElement, double arr[][] ,String fileNameOut)
		 throws IOException {
		 	
	    PrintWriter writer = new PrintWriter(new FileWriter (fileNameOut, false));		 	
		
		/* Store key name */
		writer.print("GeneID" +"\t");
		
		/* Store the rest of sample name */
		for (int i=0; i<bioAssayNameList1.length; i++){
			writer.print(bioAssayNameList1[i] +"\t");
		}

		for (int i=0; i<bioAssayNameList2.length; i++){
			writer.print(bioAssayNameList2[i] +"\t");
		}
		writer.println();

//-----------------------------------------------         	
  	int count=0; /* To iterate the common key array*/
  	/*Need to write the file indicator to the outputfile*/
  	 if (SaveFileIndicator.equalsIgnoreCase("YES")) {
      	/* Write out the source */
         writer.print("Sourse" +"\t");
             
         /* For the first source */

 		for (int i=0; i<bioAssayNameList1.length; i++){
			writer.print(sourse1 +"\t");
		}
 		/* For the second source */
		for (int i=0; i<bioAssayNameList2.length; i++){
			writer.print(sourse2 +"\t");
		}
         writer.println();     	 	
  	 }
  		
     /* Write out the DWD standardized output array*/
     int row = arr.length;
 	int col = arr[0].length;
  		
 	for (int i=0; i<row;i++){
 		
         String keys = (String)commonDesignElement.get(count);
         writer.print (keys + "\t");
		/* The add data elements back*/
 		for (int j=0; j<col; j++) {
             writer.print(arr[i][j] +"\t"); 
 		}
         count++;   
         writer.println(); 
         writer.flush();
  	}
     writer.close();
    	
	}	/* End of filePostProcess*/

}